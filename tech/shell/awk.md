# awk
[TOC]

awk分别代表其作者姓氏的第一个字母。因为它的作者是三个人，分别是Alfred Aho、Brian Kernighan、Peter Weinberger。
awk有3个不同版本: awk、nawk和gawk。
gawk是awk的GNU版本，它提供了Bell实验室和GNU的一些扩展。下面介绍的awk是以GUN的gawk为例的，在linux系统中已把awk链接到gawk
[The GNU Awk User’s Guide](http://www.gnu.org/software/gawk/manual/gawk.html)
[AWK编程语言](http://bbs.linuxtone.org/thread-24441-1-1.html)
[AWK程序设计语言](http://awk.readthedocs.org/en/latest/chapter-one.html)
[Awk tutorials](http://www.grymoire.com/Unix/Awk.html)
[awk 手册](http://www.aslibra.com/doc/awk.htm)
[Unix awk使用手册（第二版）](http://net.pku.edu.cn/~yhf/tutorial/awk_manual.html)

## 行为
逐行扫描文件，查看是否匹配模式（缺省则默认匹配），如果匹配则在这些行上进行你想要的操作（缺省为显示到标准输出）。

### awk的一般执行流程
读入一条记录（使用RS划分）放入`$0`，而后按FS划分为域`$1`, `$2`, `$3`, ...
按序使用每个模式进行匹配，匹配成功则执行动作
注意：在动作中修改RS或FS是从下一行才开始生效的，欲使其在读入第一行前就生效，可以使用BEGIN模式

## 格式
```
awk [options] 'script' [var-set] file(s)
```
file(s)指定要处理的输入文件，可以指定多个，如果未指定则从stdin获取

### 选项
+ -f scriptfile
可以指定执行脚本文件
awk脚本中，如果第一行写为`#!/bin/awk -f` 并给文件以执行权限，就可以直接用该脚本名进行调用
+ -F fs
指定域分割符fs（可以是一个正则式的字符串），此处指定的从第一条记录就会生效。如果不指定，相当于-F' '（注意-F' '不同于-F'[ ]'也不同于-F'[ ]+'，-F'[ ]'表示仅以单个空格为分隔符，-F'[ ]+'表示以一个或多个空格为分隔符，-F' '以一个或多个空白符为分隔符，且忽略先导的空白符）
+ -v var=value
赋值一个用户定义变量（每一个var对应一个-v选项，这是沟通shell变量和AWK变量的好办法）
*注*：和在var-set位置进行变量赋值的差别是：-v 赋值的的变量是在BEGIN 块执行前赋值的，而var-set 赋值的变量是在BEGIN 块执行后赋值的
+ -W option
根据option的不同会有不同的功能

### awk脚本
由模式和动作组成的：
```
pattern {action}
```
两者是可选的。
如果没有模式，则每条记录都匹配，即action应用到每条记录，相当于对于任意行均匹配；
如果没有action，则输出匹配的记录，相当于{ print }动作。

#### 模式
模式可以是单一的表达式，也可以是表达式的组合
##### 表达式
BEGIN：让用户指定在第一条输入记录被处理之前所发生的动作，通常可在这里设置各种变量。（不需要输入文件）
END：让用户在最后一条输入记录被处理之后发生的动作。
布尔表达式：
关系表达式：可以使用 >、<、>=、<=、==、!= 进行判断（这种判断也可以放到动作中使用 if 语句进行判断），是字符串或数字的比较，如`$2>$1`选择第二个字段比第一个字段长的行。
模式匹配表达式：用运算符 ~ (匹配)和 !~ (不匹配)。
/正则表达式/：awk支持的正则元字符见下。相当于`$0 ~ /re/`

##### 表达式的组合
表达式 && 表达式
表达式 || 表达式：进行逻辑组合
表达式1 , 表达式2：捕获匹配两个表达式和其之间的内容, 该语法不能包括BEGIN和END模式。如果表达式2找不到匹配，则将匹配到文件结束

#### 动作语句块
可以以换行或分号分隔，语法类似C，只不过最后一条动作语句后可以不用换行或分号
长动作语句可以使用“\”续行（不过如果在逗号、左括号、&&、||、do、else、if/while/for/函数定义的右圆括号之后可以不用“\”）

##### 行注释
`# comment`

##### 内置的变量（可在awk脚本中使用，可读写）：
RS	记录分隔符，默认是\n，即对输入以行分割，每一行为一条记录
FS	域分割符，默认是空格或tab键，即对于一条记录中，用空格或tab键分割成不同的域
ORS	输出记录分隔符(默认值是一个换行符)。
OFS	输出字段分隔符(默认值是一个空格)，如使用`print $1, $3`中的逗号将替换为OFS
`$0`	当前读入的记录
`$1、$2、...、$NF` 当前记录中的各个域，默认类型为字符串，除非是全数字，才根据应用环境决定是数字还是字符串
NR	当前处理的是第几条记录，从1开始计 （BEGIN时为0，END时为NR最后的值，即总的记录数）
FNR	同NR，但相对于当前文件，从1开始计 （BEGIN时为0，END时为FNR最后的值，即最后一个文件的总记录数）
NF	当前记录所拥有的域的数目
FIELDWIDTHS	字段宽度列表(用空格键分隔)。
ARGC	命令行参数的个数。
ARGV    命令行参数的数组（序号从0 到ARGC-1）。
ARGIND  当前正在处理文件的编号(BEGIN时为0，处理第一个文件时为1，依次类推，END时为ARGIND最后的值，即处理的文件数)。
FILENAME	当前文件名。
CONVFMT 数字转换为字符串格式(默认值为%.6g)
OFMT	数字的输出格式(默认值是%.6g)
ENVIRON	环境变量关联数组。
ERRNO	最后一个系统错误的描述。
IGNORECASE  如果为真（1），则进行忽略大小写的匹配。
SUBSEP	数组下标分隔符(默认值是\034)。
RSTART	由match函数所匹配的字符串的第一个位置。
RLENGTH	由match函数所匹配的字符串的长度。

##### 数据类型
###### 基本数据类型
数字和字符串

1. 数字
包括integer、decimal和科学计数法，但在内部计算时都是基于浮点数的，即使布尔值的true也表示为1.0
2. 字符串
使用双引号括住，其中可以使用`\` 转义字符
两个字符串写在一起（中间可以使用空格分隔），就视为字符串连接。
*注：由于awk 常用单引号包装awk 代码，使用如果想在awk 代码中使用单引号，无法简单的使用转义符，不过可以使用\047 来作为单引号字符*

类型取决于上下文并在需要时自动转换

如果字符串和数字做关系运算时，数字将转换为字符串参与运算
做布尔判断时，仅当字符串为空串，和数字0是false，其他均为true

变量无需声明，在其第一次被引用时被初始化为空串（同shell），而如果是参与算术运算会被初始化为0.

###### 数组
字符串和数组的位序都从1开始记
注意：awk 的数组其实是一个字典（关联数组），索引是字符串类型，当访问时动态增加或修改元素
delete array[key]删除数组元素
delete array删除整个数组

+ in的用法
当array[key]存在时，key in array为 1，否则为 0

+ 遍历
`for(key in array) statement`，但索引的遍历顺序不定
也可以使用类似C 的遍历

+ 多维数组
`array[key1, key2]`或`array[key1 SUBSEP key2]`
这里SUBSEP是一个特殊的字符串\034，从而将一个二维表示转换为一个唯一的一维表示
    - 索引元素 `A[i,j]`
    - in的用法变为为 `(i,j) in A`，
    - 如果用一维数组的`for(item in array)`的遍历方式，则须使用split()函数来访问单独的下标分量：`split(item, subscr, SUBSEP)`，从而下标分量为`subscr[1]`、`subscr[2]`

##### 运算符（按优先级从高到低）
`$`	字段引用
++、--	自增自减（包括前缀、后缀）
`**`、^ 幂（右结合）
+、-	单目
!、~	逻辑非，位反
`*`、/、%
+、-	双目
<<、>>  移位
字符串连接
关系（<、>、<=、>=、==、!=）
匹配（~、!~）
in	含于数组
&&
||
?:	三目	右结合
赋值（=、+=、-=、`*=`、/=、%=、^=）	右结合

##### 正则
awk脚本的正则表达式都写在/.../之中，匹配运算符用 `~`，反之，不匹配用 `!~`
如：`expr ~ /re/`
支持ERE 正则

###### gawk的专用正则元字符（不适合unix版本的awk）
\Y	匹配一个单词开头或者末尾的空字符串。
\B	匹配单词内的空字符串。
\<	匹配一个单词的开头的空字符串，锚定开始。
\>	匹配一个单词的末尾的空字符串，锚定末尾。
\w	匹配一个字母数字组成的单词。
\W	匹配一个非字母数字组成的单词。
\‘	匹配字符串开头的一个空字符串。
\'	匹配字符串末尾的一个空字符串。

##### 显示
print "..." NR "..."
如果不写输出串，单独的一个print，则将打印当前 $0 的值。
打印的变量不能是数组（不能直接打印）
用空格分隔是作为输出，将连接为一个字段；而用逗号分隔则视为不同字段，将用OFS分隔。
print一次作为一条记录输出，自带ORS分隔
******
printf "格式串", val1, val2, ...
该方式不作为记录输出，所以就不带ORS分隔

###### 重定向
可以在输出语句后跟一个  >"ofile"  或  >>"ofile"  做输出重定向（注意：文件名用双引号）
注意：
如果输出表达式中含有大于号（>），要加上括号隔开表达式，避免被误判为重定向符号。
重定向相当于打开文件，可以使用close关闭文件（关闭文件名）：
```
awk '{ print FILENAME,$0 }' file1 file2 file3 > fileall
awk ' $1!=previous { close(previous); previous=$1 } {print substr($0,index($0," ") +1) > $1}'
```

###### 管道
```
$awk '/west/ {count++}
	{printf "%s %s\t\t%-15s\n", $3,$4,$1 | "sort +1"}
	END {close "sort +1"}' datafile
```
由于shell命令也要等到awk结束或管道关闭才从管道读入（而且无论管道还是使用某个文件进行读写，都必须先关闭一个，才能打开另一个）。
此外，就是由于管道内相当于一个子进程，所以里面赋值的变量都不会影响父进程，于是也就无法直接传值给shell。
注意：
shell命令也要用引号
关闭管道，就是关闭接收管道输入的命令

##### 输入
getline var
该输入将从处理文件中读入下一行，并影响NR、FNR等内置变量；如果var缺省，则写入$0，并修改NF

###### 重定向
getline var < "file"
输入从 file 文件中读入，可以通过返回值判断（成功读取，返回1，如果遇到EOF，则返回0，否则返回-1）来进行不断读入
文件将被持续打开，文件名字符串相同就使用之前打开的文件继续读入，直到调用close 关闭
如果想要获取终端的输入，file可以使用"/dev/tty" 或 "-"

###### 管道
```
awk 'BEGIN{ while(("ls" | getline d) > 0) print d}' file
```
其中，字符串"ls" 通过调用popen（r打开）子进程，后续发现"ls"字符串调用，只要字符串相同就使用同一管道取后续数据，直到调用close("ls") 关闭该管道

**注意：这里由于使用的popen 打开的管道，而且对于一个字符串只打开一个管道，所以只能只读或只写，而不能同时。即print | "tee aa" | getline d 的命令是行不通的**

##### 流程控制
exit 直接退出，执行END块（除非在END块中执行）（类似awk自身循环的break），后面可以跟一个表达式，表达式的值作为awk命令的返回值
next 结束当前行的处理，读取下一行（类似awk自身循环的continue）
类似C 还有：if-else语句，while、do-while语句，for、for(key in array)语句，continue、break语句

##### 函数
```
function funname(p1, p2, p3)
{
    statements;
    return value;
}
```
只能返回标量，不能是数组
标量直接传值，数组则传引用（数组可以从参数返回）
类似shell的函数，函数中的变量都是全局的（参数除外），所以函数中也可以直接引用内置变量
如果调用时，给的参数可以不等于定义的参数个数，则多余的参数定义视为函数的局部变量，而多余的实参则会被忽略

###### 内置函数
+ 算术

int（截断取整）、sqrt（平方根）、exp（自然指数）、log（自然对数）、sin、cos、atan、atan2(y, x)（y/x的反正切）
rand（随机数`[0,1)`）、srand([expr])（设置随机种子为expr，若省略为时间，返回先前的种子值）

+ 位运算

and（位与）、or（位或）、xor（位异或）、compl（按位取反）
lshift(val, c)、rshift(val, c)（val 左移、右移c 位）

+ 字符串

length([str])、blength([str])
返回字符串str的字符数（字节数），若省略str，则str=`$0`

substr(str, i [, n])
返回字符串 str 从位置 i 开始 n 个字符的子串（n若省略则到串尾）

split(str, substr[, sp])
将字符串 str 用 sp （支持正则串）切割，分为子串的数组substr（下标从1到N），返回数组的长度N；若sp 缺省，则 sp=FS

tolower(str)、toupper(str)
返回将str所有字符转换为小写（大写）的字符串。大写和小写的映射由当前语言环境的 `LC_CTYPE` 范畴定义。

strtonum(string)
字符串转换为数字

sprintf(format, expr, expr, ...)
格式化字符串（见附），并返回之（格式化方式同printf）

index(str, find)
返回字符串 str 中 字符串 find 首次出现的位置，若找不到，返回0

match(str, re[, a])
返回字符串 str 中 正则表达式 re 首次匹配的位置，若无匹配，返回0。另外，函数执行后还会设置两个awk变量，RSTART=返回值，RLENGTH=匹配命中的长度（无匹配时为-1）
如果还想要提取re中的分组，需要带第三个参数，它作为一个输出参数，将输出一个数组，a[0]表示匹配的整个字符串，a[1]、a[2]...依次表示各个匹配的分组，还可以通过a[1, "start"]和a[1, "length"]得到分组命中的位置和命中长度

sub(re, replace[, str])
在str中，用字符串replace替换，被正则表达式re首次匹配命中的字符串，返回替换的数量，若str缺省，则str=`$0`。注：若replace中有 & 符，则用表示该部分使用re命中的字符串（效果等同于s/re/replace/）

gsub(re, replace[, str])
同上，只不过会对所有命中的字符串都做替换（效果等同于s/re/replace/g）

gensub(re, replace, how[, str])
replace不光可以使用 &，还可以使用`\\n`之类的进行正则分组引用
比上面多了参数how，可以指定对第几次匹配命中执行替换，也可以指定"g"，表示全部替换
若str缺省，则指`$0`
返回值为target替换后内容(未替换还是返回 target原内容)，与sub、gsub不同的是，target内容替换后不改变。
```
gensub(/a(.*)b/, "\\1" ,1)        # 返回值为匹配正则第1对()内的内容
gensub(/a(.*)b(.*)c/, "\\2", 1)   # 返回值为匹配正则第2对()内的内容
```

+ 数组

length(arr)
返回数组长度

asort(srcarr[, dstarr])
对数组srcarr的值进行排序，若有参数dstarr，则将排序结果（纯数字按数值排序，生成新的键为从1递增）放入dstarr，srcarr不变；若没有参数dstarr，则将排序结果直接放入srcarr，数组原来的键丢失。返回数组长度

asorti(srcarr, dstarr)
对数组srcarr的键进行排序，将排序结果（注意由于键始终是字符串类型，所以，asorti也始终是字符串排序）放入dstarr，srcarr不变，返回数组长度

+ 其他

close(name)
关闭打开的文件或管道，name是管道命令字符串，或打开文件的文件名字符串。成功关闭返回0，否则非0.
可以刷新缓冲。

system(strCmd)
以shell命令的字符串作为参数，strCmd可以将awk变量和字符串用空格拼成一个shell命令，例如：
```
awk 'BEGIN {system("echo \"Input your name:\\c\""); getline d;print "\nYour name is",d,"\b!\n"}'
```
创建子进程执行命令，返回子进程的退出状态（类似C 的system() 函数）
其输出结果将被直接打印

systime()
返回当前秒级时间戳

mktime("YYYY MM dd HH MM ss[ DST]")
返回指定时间的时间戳

strftime([format [, timestamp]])
格式化时间戳（见附），返回字符串
格式字符串的语法格式如下：
`%[flag][width]format_character`
其中：
可选的标记（flag）可以是：
| flag | 说明 |
| - | 连字符，不填充数字区域 |
| _ | 下划线，使用空格填充数字区域 |
| 0 | 数字 0，使用 0 填充数字区域。日期的数字区域默认是以 0 填充的 |
| ^ | 使用大写字母 |
| # | 使用相反的大小写字母 |
可选的输出域宽度（width）是一个十进制数字
format_character 参考下面附录

## 附
### 格式化字符串
| 格式符 | 说明 |
|---|---|
|%d	|十进制有符号整数|
|%u	|十进制无符号整数|
|%f	|浮点数|
|%s	|字符串|
|%c	|单个字符|
|%p	|指针的值|
|%e	|指数形式的浮点数|
|%x	%X |无符号以十六进制表示的整数|
|%o	|无符号以八进制表示的整数|
|%g	|自动选择合适的表示法|

### 格式化时间戳
| 格式符 | 说明 |
|---|---|
|%c	|本地日期和时间|
|%x	|本地日期(08/20/99)|
|%X	|本地时间(12：00：00)|
|%D	|日期 08/20/99|
|%Y	|4位年份|
|%y	|两位数字表示的年(99)|
|%m	|十进制表示的月份|
|%B	|月名的完整写法(October)|
|%b	|月名的缩写(Oct)|
|%d	|十进制日期(2位)|
|%e	|日期，如果只有一位会补上一个空格|
|%w	|十进制表示的星期几(星期天是0)|
|%a	|星期几的缩写(Sun)|
|%A	|星期几的完整写法(Sunday)|
|%H	|用十进制表示24小时格式的小时|
|%I	|用十进制表示12小时格式的小时|
|%M	|十进制表示的分钟|
|%S	|十进制表示的秒|
|%p	|12小时表示法(AM/PM)|
|%j	|从1月1日起一年中的第几天|
|%U	|十进制表示的一年中的第几个星期(星期天作为一个星期的开始)|
|%W	|十进制表示的一年中的第几个星期(星期一作为一个星期的开始)|
|%Z |时区(PDT)|
|%%	|百分号(%)|


<http://blog.csdn.net/tolys/article/details/1807523重定向和管道>


