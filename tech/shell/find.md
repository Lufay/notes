# find

## 格式
```
find [options] [path...] [expression]
```
其中
options 是查找选项
path 是查找的起始目录，可以有多个，缺省为 `.`
expression 是查找表达式，缺省为 `-print`

### 查找选项
-P		不追踪符号链接（默认行为），只检查或打印符号链接自身
-L		追踪符号链接，不检查或打印符号链接自身
-H		除在命令行参数中指定的的符号链接外，其他都不追踪
-D debugoptions		查询调试，打印诊断信息
	debugoptions 包括：
	help：解释调试信息
	tree：显示表达式树的原始和优化形式
	stat：用stat 和lstat 系统调用打印文件信息
	opt：打印表达式树优化的诊断信息
	rates：打印断言成功或失败的总结信息
-Olevel	查询优化

### 查找表达式
表达式返回一个布尔值，用于判断当前遍历的路径是否返回，支持短路判断
表达式由选项、测试、动作、表达式运算符组成

#### 选项
都返回true，由于选项将对后面的测试和动作产生影响，故必须在所有测试、动作之前
-depth		在检查目录本身之前先检查目录内容（默认为先检查目录本身是否符合，在检查器内容）（可以缩写为-d，不过不推荐）
-maxdepth n	从指定目录下至多找n层，若n指定为0，则只对指定目录（文件）进行搜索，而不会进入目录中
-mindepth n	从指定目录下的n层开始找，若n指定为1，则不对指定目录（文件）进行搜索，直接进入目录中
-regextype type	正则语法规则，当前实现了emacs（默认）， posix-awk, posix-basic, posix-egrep and posix-extended
-xdev		不检查其他文件系统的目录

#### 测试
其中的数字参数：n表示准确值n，+n表示`>n`，-n表示`<n`
-name pattern	将文件名按模式pattern进行匹配，在pattern中除可以包含通配符`?  *`，还可以包含范围匹配组`[]`（不过这两个符号默认作为常规字符，需使用`\`进行转义），在中括号内可以写若干个字符，也可以写一连串字符，如a-z表示字符“a”到字符“z”的任意一个字符，一个匹配组用于匹配一个字符和“?”不同就在于它限定了匹配范围，而非任一字符。
-iname pattern	匹配模式时，不区分大小写
-regex pattern	文件名正则匹配，是对路径的全匹配而不是部分匹配
-iregex pattern	同上，不区分大小写
-path pattern	匹配路径，注意是路径而非目录，所以使用通配符时，不会特殊考虑“/”字符，如`sr*sc`可以匹配到“./src/misc”。该选项常常和“-prune”动作联用，用于忽略指定路径。注意：如果pattern的路径超出find指定的路径，则不会匹配任何内容

-size n单位		按文件大小匹配，单位包括b：块（512bytes），c：byte，w：字（2bytes）k：kilobytes(1024)，M：Megabytes(1048576)，G：Gigabytes(1073741824)
-empty			普通文件或目录文件为空的

-type b/c/d/p/l/f/s	按文件类型匹配：b块设备（默认）、c字符设备、d目录、p命名管道、l符号链接、f普通文件、s套接字
-fstyle type	按文件所在的文件系统类型匹配，文件系统类型通常可以在配置文件/etc/fstab中找到

-user uname		按文件所有者(通常是建立文件的用户)进行匹配
-nouser			无效所有者（其所有者账号可能被删除）文件（即：文件的所有者在/etc/passwd中不存在）
-uid m			按文件所有者的数字ID：m进行匹配
-group gname	按文件所属群组名gname进行匹配
-nogroup		无效所属群组文件（即：文件所属群组在/etc/groups中不存在）
-gid m			按文件数字群组ID：m进行匹配

-amin num		按文件最近一次访问时间匹配，同上
-atime num		同上
-anewer file	文件最近一次访问时间比file文件修改时间要近的
-cmin num		按文件最近一次数据元（例如权限等）改变时间匹配，num表示的数字指分钟，具体在上面说明
-ctime num		按文件最近一次数据元（例如权限等）改变时间匹配，num表示的数字指天，同上
-cnewer file	文件最近一次数据元（例如权限等）改变时间比file文件修改时间要近的
-mmin num		按文件修改时间匹配，同上
-mtime num		同上
-newer file		文件修改时间比file文件修改时间要近的
-used n			文件最近一次访问是在它最近一次状态改变（创建）后的n天

-links num		按硬链接数n进行匹配
-samefile name	和name指向相同的inode的文件（如果-L有效，则还包括符号链接）

-perm mode		按权限匹配，这里mode有4种表示：直接写（exactly），“-”前缀（all），“/”前缀（any），“+”前缀（deprecated）。差别在于直接写要求和mode完全匹配，不能有更多的权限；“-”前缀则只要求至少拥有这些指定权限，当然更多权限也可以匹配；“/”前缀更为宽松，表示至少有这些指定权限之一；而“+”前缀是不推荐的，因为权限表示中也可以有+，这样容易造成语法断句错误。权限的表示有两类，一类是3个八进制数，另一类是符号表示。因为1位八进制数可以转为3位二进制数，可以分别表示读写执行三种权限；而这3个八进制数分别表示所有者、群组、其他用户。只不过有时为了明确表示这是一个八进制数，需要加一个领头的0。而符号表示则较为复杂：用a表示所有人all，用u表示所有者，用g表示所属群组，用o表示其他用户；而后紧跟一个+或=；再用r表示读w表示写x表示执行。如a+rw表示666，u=rw,g=rw表示660
-readable		文件可读，该测试考虑访问控制列表和那些被-perm测试忽略的其他许可（这项测试使用了access系统调用）
-writable		文件可写，同上
-executable		文件可执行，或，目录可搜索，（这项测试使用了access系统调用，而有些access通过却并不能访问的文件，因此，这里输出的结果也并能保证一定能被执行或访问）

-true和-false	逻辑常量

#### 动作
-exec command	如果命令返回状态为0, 则返回true。在command命令之后在“;”之前的内容都将视为该command的参数。该命令可使用“{}”表示当前进行筛选的文件。如果使用“;”收尾（通常需要用“\”进行转义），该命令将在那些匹配成功的文件上执行一次；还可以用“+”收尾后面加上文件名，则命令只对匹配成功，且文件名在这些指定之中的执行，此时只允许使用一次“{}”。该动作对起始find的目录有效。
-execdir command	基本同上。差别在于该动作对起始find的目录无效。（此种方法更为安全，因为它避免了在解析匹配文件路径时的竞争条件）。使用该选项必须确保$PATH环境变量没有引用“.”，否则，攻击者可通过留下一个精巧命名的文件在你可能执行该动作的地方，就能够执行他想要执行的任意命令。
-ok command ;	和-exec基本相同，只不过在执行前会首先询问用户，如果用户同意则执行，否则，就返回false。在command执行时，其标准输入被重定向到“/dev/null”
-okdir command ;	和—execdir基本相同，另外加上-ok的询问
-delete		删除文件，如果成功删除返回true，否则报告错误信息（自动开启-depth选项）
-ls			返回true。对每个查询结果使用ls –dils命令进行输出
-fls file	返回true。同-ls，只不过结果输出到文件，其他参照-fprint
-print		返回true。每行显示一个查询结果
-print0		返回true。每个结果用'\0'分隔，通常可以接上xargs -0。这样可以避免结果中包含分隔符而导致的错误
-fprint file	返回true。将print的结果输出到文件。如果该文件不存在，则创建文件；如果该文件已存在，则文件内容将被覆盖。有一些特殊的文件“/dev/stdout”和“/dev/stderr”指定了标准输出和标准错误输出“/dev/null”则指丢弃输出。此外，即使没有匹配项，该文件也会被创建
-printf format	返回true。使用“\”转义字符和“%”占位符（表示文件的各种属性，可以参照man手册），进行格式化输出
	+ 常用转义字符：
	\n	换行符
	\t	水平制表符
	\\	字符“\”
	+ 常用占位符：
	%%	字符“%”
	%f		文件名
	%h		文件的所在路径
	%p		文件路径和文件名（如果想要去除查找路径前缀的路径和文件名用%P）
	%s		文件大小（字节数）
	%a		按C语言的ctime函数格式化最近访问时间
	%A_		使用@或C语言中的strftime函数中的指令跟在“A”后选择输出时间格式（@表示从1970年1月1日0时起的秒数，其他略）
	%c		按C语言的ctime函数格式化最近状态改变（创建）时间
	%C_		同A
	%t		按C语言的ctime函数格式化最近修改时间
	%T_		同A
	%m		文件的访问权限位（以八进制形式，如果想要ls的显示形式可用%M）
	%y		文件类型（如ls显示）U=unknown type
	%b		分配的磁盘块（512字节）数
	%u		文件所属用户的名字（如果没有就用户ID，如果想要，可以直接用%U）
	%g		文件所在群组名（如果没有就群组ID，如果想要，可以直接用%G）
	%d		自指定目录下的目录树深度（即指定目录文件为0）
	%n		文件的硬链接数
	%F		文件所在的文件系统类型
-fprintf	返回true。同-print，只不过结果输出到文件，其他参照-fprint
-prune		返回true。如果找到了一个匹配文件为目录，就不再对目录内进行搜索。因此，如果指定了-depth选项，该动作将失效
-quit		遇到该选项立即退出find，如果在他之前有显示相关的选项则能够显示一个文件，如果显示选项在其后则不会有任何输出

#### 运算符
优先级依次递降，两个exp之间没运算符时，默认为-a。
()
!或-not
-a或-and
-o或-or
exp1, exp2（逗号表达式，虽然exp1和exp2都被计算，但exp1的结果被抛弃，最终是exp2的结果）
**附注：符号()!，对于shell而言比较特殊，所以有时需要用“\”进行转义**
由于短路求值的存在，对于那些返回为true的，如果使用“-o”则后面筛选将失效，这一点对于-prune是很有用的，因为它保证了被-prune禁入的目录，后面的筛选也不会应用到这些目录

## 使用说明
1. 由于有些文件对当前用户可能没有访问权限，会导致一些错误信息，可以使用错误重定向`2>/dev/null`忽略出错信息，其中2就是stderrstream 2错误流
1. 在使用find命令的-exec选项处理匹配到的文件时，find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。
这就是xargs命令的用处所在，xargs命令每次只获取一部分而不是全部，它可以先处理最先获取的一部分，然后是下一批，并如此继续下去。在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高；而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定
