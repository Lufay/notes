# 语言特性
Lua 用标准C语言编写，编译后仅仅一百余K，可以很方便的嵌入别的程序里
Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。

# 安装 & 执行
Mac: `brew install lua`

交互式：`lua -i`
执行脚本：`lua xx.lua`
脚本文件头：`#!/usr/bin/env lua`并添加可执行权限，则可以使用`./xx.lua` 执行

交互模式的每一行，一个文件 都被称为是一个chunk

命令行参数可以通过arg来获取，它是一个table，可以使用整数索引，0是脚本名，负数可以索引 lua 命令及其参数，正数可以索引自己的参数


# 开始
大小写敏感
单行无需结尾分号，除非一行写多条语句，则多条语句用`;` 隔开
内置的全局变量是以下划线开头和大写字母组成，比如_VERSION、_PROMPT（命令行提示符），所以命名标识符尽量避开

除非使用local声明，否则都是全局变量。应尽量使用局部变量，因为能避免名称冲突，而且局部变量比全局访问更快
使用local后，变量将限定于其所在代码块（如，控制结构、函数体、chunk）中，注意：在代码块内，而在local声明前使用的依然是全局变量。

print("Hello World!")

## 注释
```lua
-- 单行注释

--[[
    块注释
]]--

--[[
    块注释，可以省略结尾的--
]]

--[=[
    块注释，可以在加入任意多个=
]=]
```


# 类型
使用函数type(obj) 可以得到变量或值的类型（返回的是一个字符串）

## nil
未定义，未初始化的变量的值。仅有一个单例，作为布尔值为false
所以删除一个变量，只需将其赋值为nil

## boolean
两个实例：true/false
除了false和nil，其他作为布尔值都是true（包括数字0）

## number
实数（相当于double 类型）

`tonumber(str, base=10)` 可以将字符串转换成指定进制（最多36，即10+26个字符）的数字，转换失败返回nil
`num + str` 尝试将str 转为一个number 然后执行计算

### math库
math.pi
math.sin(number)
math.cos(number)
math.sqrt(number)
math.random(n)

## string
字符串，不可变类型，字节序列，因此可以保存二进制数据
使用单引号和双引号均可
`"\u{3b1} \u{3b2} \u{3b3}"` 可以使用UTF-8 编码的字符

`#str` 获取字符串str（可以是变量，也可以是常量）的长度
`str1 .. str2` 字符串连接（如果不是字符串，也会先转为字符串再连接）
`assert("2" > "15")` 按字典序进行比较
`tostring(num)` 将数字转换为字符串

### 多行字符串
```lua
str = 'aa\
bb'

multi_line = [[
    多行字符串会忽略前置的换行符，不解析转义字符
]]

multi_line = [=[
    和注释一样，= 可以添加多个，只要一致就行
]=]
```
所以，字符串中除了和C相同的转义字符外，还需要对`[`和`]`进行转义
Lua 5.2及其之后引入了一个转义符`\z`，它将忽略后面的明文空白符（不包含使用转义字符的空白符），直到遇到非空白符为止。

### string库
`string.char(97,98,100)` 将使用各个字节码表示的字符组成一个字符串
`string.byte(str, idx=1, ...)` 返回指定位置字符的字节码，若未指定默认为首字符（位序从1 开始），限于栈容量，最多返回一百万个值
`string.format(fmt, arg...)` 类似sprintf，fmt 可以使用`%s %02d %x %f %.2f` 等形式的占位符，flag：cdioux表示的是不同格式的一个整数；efg表示不同格式的一个浮点数；sq表示一个字符串（q返回一个使用双引号包围的原字符串，并对其中的双引号进行转义）
`string.len(str)` 相当于`#str`
`string.find(str, pattern, pos=1)` 从str的pos 位置开始找pattern（可以是正则表达式，可以用`%a %d %s` 分别表示字母、数字、空白符），返回找到模式在原字符串中的起始和结束位置返回，找不到返回nil
`string.rep(str, n)` 重复n 次连接
`string.reverse(str)` 反转
`string.lower('Hello')`
`string.upper('Hello')`
`string.sub(str, start, end)` 返回位序从start 到end（包括）的子串（支持负位序，最后一个位序为-1）
`string.gsub(str, pattern, replace)` 模式替换，返回替换后的字符串和替换次数

## table
关联数组，可以模拟array/dict/struct等多种数据结构。
key 可以是除nil和NaN之外的任何Lua类型（数字key都会被转换为接近的整数），value可以是nil外的任意类型

### 构造table
构造时，会先将指定key 的字段，从左到右的先后次序放入table中；再将未指定的key 按从左到右先后次序，用从1开始的连续整数作为key（这被称为表的序列成分）放入table 中
若其中有重复的key，则按入table 的先后次序，进行覆盖
多个字段之间可以使用逗号或分号分隔（通常用分号分隔不同类的字段），最后一个字段后面的分隔符是可选的
```lua
d = {}  -- 创建一个空的table

p = 3
d = {1, p='a', 'b', k='c', 'd', [10]='e', [p]='f', ['p']=0}
```
这里没用`[]`指定的key 会转换为字符串key，用了`[]`指定的key 会先求值再作为key

### 索引
索引key 有两种方式：
t.field 这里field 会自动转换为字符串作为索引
`t[field]` 这里是更一般的用法

将指定key 赋值为nil，就相当于删除这个key

### table库
table.insert(tbl, pos, item)      将item插入表tbl的pos位置（从原pos位置元素后依次后移，代价较大）；若pos缺省，则为push操作
table.remove(tbl, pos)    从表tbl中移除位置pos 的项（后继前移，代价较大）并返回之；若pos省略，则为pop操作（序列部分的最后一项）
table.concat(tbl, sep, i, j)    将一个由字符串和数字组成的表中，从位置 i的元素到位置 j的元素，用sep连接起来，返回这个连接字符串。sep缺省为空串，i缺省为1，j缺省为数组长度
table.unpack(tbl, i, j)       将数组tbl解析为多值，需要用到unpack函数，i为指定的起始位置（默认为1），j 为指定的结束位置（默认为数组长度）
table.pack(...)                将多值封装为一个table，按序对应1，2，3，...，此外还有一个 n 域，表示数组的长度

## userdata
可以保存C数据（通常是 struct 和 指针）
仅有赋值和相等判断运算

## function
函数对象（可以是C 或 Lua 编写的函数）

## thread
协程对象

# 运算
`^` 优先级最高，单目高于双目
除`^`和`..`都是左结合

其余按优先级如下

## 长度运算符
`#` 用于字符串或table的前，返回字符串的字节数或 table 中序列成分的长度

## 算术运算符
`+ - * / % ^`和`取负-`
当一个字符串参与算术运算时，会自动转换为number
没有自增自减，以及本地运算符
lua5.3 新增了整除运算符`//`（会将结果进行下取整）

## 字符串连接
`..` 如果对number使用该运算符，则number也会自动转换为字符串（运算符要和number 分开，否则就会被解析为小数点）
由于字符串是不可变类型，因此这个连接意味着要创建一个新的字符串并拷贝内容

## 关系运算
`<    >    <=    >=    ==    ~=`
返回布尔值。类型不同就不等（在进行进行关系判断时，并不会发生自动转换，因此'10' 不等于10）
对于table、userdata、function比较的是对象引用，即是否是同一对象。

## 逻辑运算符
and    or    not
其中，not 返回布尔值。而其他两个返回的并非布尔值，而是短路返回，如下： 
a and b    a为false，返回a；否则返回b
a or b     a为true，返回a；否则返回b

## 赋值
支持多元赋值（多元之间使用逗号分隔），过程是统一计算好右值之后，依次赋给左值。如果右值个数较多则多余将被忽略，如果右值个数较少，则不足部分被赋为 nil
因此，支持`x, y = y, x` 这样进行交换两个变量的值

# 语句结构
## 简单代码块
```lua
do
    block
end
```

## 条件
```lua
if cond then
    block
elseif cond then
    block
else
    block
end
```

## 循环
在循环中，不要试图改变控制变量var，var自动被声明为循环内有效的局部变量

### while
```lua
while cond do
    block
end
```
当cond == false 时退出循环

### repeat
```lua
repeat
    block
until cond
```
当cond == true 时退出循环

### for
```lua
-- 整数索引遍历
for var = _beg, _end, _step do    -- 这三个值只会在循环开始时计算一次。step 缺省为1。注意，_end 会遍历到，即[_beg, _end]的双闭区间
    block   -- 若修改var 的值，不会影响遍历次数
end

-- 序列遍历，只遍历table 中的序列部分，i 从1 开始，每次+1，如果遇到nil 就停止
for i,v in ipairs(a) do
    print(v)
end

-- table 遍历，遍历table 的所有k-v
for k,v in pairs(a) do  -- v 可以直接缺省，k 要缺省的话，可以使用 _ 进行占位
    print(k)
end
```
迭代器三元素：迭代函数、状态常量、控制变量
for-in 循环会
1. 首先调用pairs 和 ipairs 返回第一个元素是迭代函数，第二个元素是table，ipairs 会返回第三个是迭代的起始索引
2. 然后每次迭代将状态常量和控制变量作为参数调用迭代函数，返回值就会赋值给迭代变量上
3. 返回值的首项作为下一轮的控制变量，如果该控制变量为nil，则循环终止

因为创建闭包的代价比table小，所以使用闭包可以构造一个迭代函数
闭包的外部函数，就是类似pairs 这样的迭代函数；闭包的自由变量来保存迭代状态

## break/return
break，跳出循环；
goto Label，Label 的格式为：`:: Label ::`
return，函数退出。
语法要求这两个语句必须是在block的最后一句，为了突破这条限制，可以使用do ... end块

# 函数
```lua
-- 多行形式
[local] function func_name(args)
    block
end
-- 单行形式
[local] func_name = function (args) block end
```
lua的函数是第一类值，可以存储在变量中，也可以指定作用域。第一种形式的函数名其实就是一个变量。
因此，可以很方便地重定义函数。

## 可变参数
args 的最后使用 ... 表示
函数中获取可变参数的方式有2种：
1. ... 直接使用这个，会得到自动展开的多元参数
   1. 这种方式可以使用select("#", ...) 来获得可变参数的数量
   2. 可以使用select(n, ...) 来获取从第n个可变参数开始的展开的多元参数（也就是切片），n 支持负索引（-1 是最后一个）
2. {...} 使用这个会得到一个可变参数组成的table

## 函数返回
没有显式返回的函数将返回nil
支持多值返回

### 尾调用
return func(arg) 此种调用
因为调用完成后无需退栈返回，因此lua可以不为尾调用构造栈，就不会有栈溢出的问题。注意：尾调用必须使用该格式，func和arg可以多种，但调用之外不能有任何运算，因为这样就必须退栈返回，不满足尾调用条件。

## 函数调用
当函数的参数只有一个，且该实参为字符串字面值或表构造时，函数调用的()可以省略
实参和形参的匹配，和赋值的规则一样，多余忽略，不足补nil

当函数调用（必须是单独一项，不能参与运算）作为多元赋值的最后一项，或者实参的最后一项，或者表构造的最后一项。则函数的多值返回将自动展开
如果想要强制单值返回（只返回首项），可以将函数调用放在()括号中，则将认为参与运算而单值返回；或者不要将其放在最后一项
如果只想要后面的部分返回值，则可以使用`_` 哑元放在不需要的前面部分来进行占位

## 闭包
lua的函数可以嵌套，内部定义的函数可以访问外部函数中的局部变量。这样就是一个闭包，外部的局部变量就成为自由变量。
自由变量是跟内部的这个函数对象绑定的。所以一个闭包都是包含独立的全新的自由变量和函数对象。