# vector
动态数组（只在尾端开放），使用更安全

## 实现方式
C 静态数组实现（连续存储），当容量不足时，重新申请一块内存进行数据迁移，因为该操作代价很大，为减少该操作，实际空间大小比存储数据所需的空间要大（空闲空间在尾部）
因此，在尾部的插入删除非常高效（除非引发数据迁移），而在其他位置则需要移动数据

## 迭代器
随机迭代器

## 使用
```
#include<vector>
```
### 构造器
4种构造器（空、拷贝、同值、区间）
区间构造例如：
```
int arr[]={9,8,7,6};
vector<int> b(arr, arr+sizeof(arr)/sizeof(int));
```
当然其他同T 有迭代器的容器就都可以
在*C++11*中有一种新的构造器（使用`initializer_list`），可以将上面的过程简化为：
```
vector<int> b{9,8,7,6};
```
**注意**：如果已知将有多少元素放入容器，则应优先选择容量初始化，或者reserve函数，减少内存分配次数，提高性能

### 方法
+ 重载=
+ assign()
赋值（同构造函数的方式）

#### 访问
+ 重载[]
类似数组的访问方式，比数组多了越界检查（assert方式）
+ at(pos)
功能同上（返回的是一个引用值，故可以实现改写），越界检查抛出异常out_of_range
+ front()
返回第一个元素的引用，要求容器非空
+ back()
返回最后一个元素的引用，要求容器非空

#### 增删
+ `push_back(val)`
增加一个对象放到最后
+ `pop_back()`
尾部删除一个元素（容器必须非空）
*注*：如果没有引起重新分配空间，受影响的仅有最后一个迭代器

+ insert
	- insert(pos, val)
	- insert(pos, n, val)
	- insert(pos, first, last)
	- insert(pos, initializer_list)
+ erase
	- erase(pos)
	- erase(first, last)
*注意*：由于动态数组实现，这些调用意味着要移动数组元素（也可能重新分配空间），所以该位置以及后续的迭代器失效（如果重新分配空间则全部失效）
+ clear()

#### 容量
+ empty()
容器是否是空

+ size()
返回当前元素个数，其返回值类型为`vector<T>::size_type`，可以用int接收
+ resize(int)
调整vector长度，如果指定小于当前长度会截断，如果大于当前长度，会使用默认值0或默认构造函数补足，也可以使用第二个参数指定补足值

+ capacity()
容器中内部数组的长度
size返回的是vector中有效数据的个数，当size==capacity时再添加元素，就会重分配空间并数据迁移
+ reserve(size_type n)
对应于resize调整size，reserve调整capacity，但实际重分配的个数一般比n要大

+ max_size()
返回该容器所能容许的最大长度

#### 比较
重载==，!=, <, <=, >, >=
相等条件：相同元素个数，对应位置元素相同（和向量的概念相同），由于它是使用迭代器逐元素比较，所以可以使用不同容器类型进行判等

### 遍历注意
当对容器进行遍历的过程中，小心会使迭代器失效的操作（增删操作）
如果需要对新增的元素进行处理，应该直接使用size()函数来判断，因为它总返回的是容器当前有效数据个数（并且该函数是inline的，效率不会受太多影响）
如果不想对新增的元素进行处理，可以先将size()的返回值进行保存

### 二维数组
用vector作为vector的元素，即`vector<vector<T> >`就可以构造一个二维结构，并且每一行的长度可以不同，例如：
```
vector<vector<int> > Array(10, vector<int>(0));
```
