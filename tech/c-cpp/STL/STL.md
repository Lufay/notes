# STL（标准模板库）
一个重要的特点是数据结构和算法的分离

## 六大组件
容器、配置器、迭代器、算法、配接器、仿函数（函数对象）
提供容器、迭代器、函数对象和算法

### STL容器
放在蛋架上的鸡蛋不会滚到桌上。它们很安全。因此，在STL容器中的对象也很安全。我知道这个比喻听起来很老土，但是它很正确。STL容器是同质的，即存储了相同类型的对象。
容器中元素归容器所有，这意味着容器可能是一个比较大的对象，而当容器过期时，存储在容器中的元素也随之过期，不过，如果元素是指针的话，它指向的数据不一定过期。
**注意**：由于这些模板类要根据模板参数类型设定各种类型typedef（包括类型的指针），所以不能定义引用类型作为模板参数

#### STL对容器中的元素的要求
该类型必须是可拷贝构造和可赋值的，这一点对于基本类型和没有将拷贝构造函数和赋值运算符私有化的类都是成立的。
对于容器的实现可以隐藏，但性能规格必须公开，以便程序员能进行相关操作的成本估计。

### STL迭代器
提供一种通用的访问容器中对象的方法，就像是指向容器中每个成员的指针。它在行为上很像指针，并且，指针也可以作为迭代器使用。STL的算法使用它在容器上进行操作，这样就为各种不同的容器类（这些容器类可能存储元素不同，可能实现方式不同）提供了统一的访问接口。
每个容器类都定义了一个合适的迭代器，而且这些迭代器都被typedef为各种模板内有效的iterator。（这些被typedef的原类型可能是指针，也可能是类似指针行为的对象）
Iterator设置算法的边界 ，容器的长度，和其他一些事情。Iterator也决定在容器中处理的方向。可以通过调用容器的成员函数begin()来得到一个指向一个容器起始位置的iterator。你可以调用一个容器的 end() 函数来得到容器最后一个iterator（就是最后一个值之后的一个位置，尽管那个位置或许并不真实存在）。

### STL函数对象
类似于函数的对象，可以是类对象，也可以是函数指针。函数对象的优点在于它可以拥有自己的成员，从而可以通过给构造函数传递不同参数产生不同功能的函数对象。

### STL算法
是标准算法，可以把它们应用在那些容器中的对象上。这些算法都有很著名的执行特性。这些算法与具体的容器无关，这样就省去了大量的工作，不用为每个容器类都添加这些算法操作。（但如果有对于特定容器更为高效的算法，容器类也会有自己算法的成员函数）


## STL 容器概述
虽然STL容器有很多共性，但却没有一个真正的抽象基类，只有一些概念化的接口特征，而并没有用到继承机制
**概念化特征**：（以X表示某种容器类型）
构造器：空、拷贝、赋值=
`X::value_type`	指出了存储在容器中的类型
X::iterator	容器的迭代器类型（满足正向迭代器的要求）
begin()		首元素迭代器
end()		超位迭代器（在最后一个元素后面的一个位置）
size()		存储元素的个数
swap(X&)	交换两个容器的内容
==，!=		判等，相等条件：size相同，且相应元素也相同

### 容器分类
通常分为为两类

#### 序列容器（线性组织）
`vector<T>`（向量）
`deque<T>`（双端队列）
`list<T>`（双向链表）
`forward_list<T>`（C++11，正向单链表）

##### 性质
要求按序排列，顺序稳定，满足该性质的还有array，但它不是STL容器，因为它不能动态调整大小
**概念化特征**：
+ 构造器
	同值构造（第一个参数指明size，第二个参数指明初值——如果省略，则采用默认值0和或默认构造器）
	区间构造（给出两个迭代子，从这两个迭代子表示的区间拷贝内容）
+ insert
	(iterator, T)	//在指定位置插入一个元素，返回一个迭代器
	(iterator, int n, T)	//在指定位置插入n个元素（同一个值）
	(iterator, iterator, iterator)	//第一个参数指定位置，后两个参数指定插入区间（来自其他对象）
+ erase		返回值：最后一个删除元素下一个位置的迭代器
	(iterator)	//删除指定位置元素
	(iterator, iterator)	//删除区间元素
+ clear()		//清空容器

#### 关联容器
基于键有序组织（可使用键进行快速查找）
`set<Key>`：普通集合，不允许重复元素
`multiset<Key>`：多重集合，支持重复元素
`map<Key,T>`：不允许Key相同
`multimap<Key,T>`：支持同Key到多的映射
C++11 给上面四种有序组织的类型对应增加一个无序组织的类型：
`unordered_map`、`unordered_multimap`、`unordered_set`、`unordered_multiset`

关联容器为了能够快速检索信息，将元素以某种结构进行存储，因此，在插入时指定插入位置是没有意义的。
其中有序组织的是基于树结构的关联容器，因此，在插入后是自动排序的；无序组织的是基于哈希结构的关联容器（一般具有更好的增删查的效率），所以是unordered
其中键为const，不能修改，但可以增删

#### 容器适配器
`stack<T>`（栈）
`queue<T>`（FIFO队列）
`priority_queue<T>`（优先队列）
不是独立的容器，只是某种容器的变种，提供原容器的一个专用的受限接口


