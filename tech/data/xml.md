# XML 和XPath
[TOC]

XML 可扩展标记语言，被设计用来传输和存储数据。由应用程序进行解析
HTML 被设计用来显示数据。由HTML浏览器进行解析
XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。

## XML
XML 标签没有被预定义。您需要自行定义标签。
XML 被设计为具有自我描述性。
XML 不会做任何事情，标签的功能性意义依赖于应用程序的特性。

XML 把数据从 HTML 分离，通过使用几行 JavaScript，你就可以读取一个外部 XML 文件，然后更新 HTML 中的数据内容。
XML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。
这让创建不同应用程序可以共享的数据变得更加容易。

### 结构
XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”

第一行是 XML 声明。它定义 XML 的版本 (1.0) 和所使用的编码 (ISO-8859-1 = Latin-1/西欧字符集)，例如：
```
<?xml version="1.0" encoding="ISO-8859-1"?>
```

下一行描述文档的根元素
每个元素结点都可以包含若干个子元素（可以重名，意义由程序决定）
每个元素都可以拥有若干个属性（位于打开标签中），属性值为字符串（引号的文本）
当然，在一对闭合的元素之间也可以包含文本
（注：尽管文本和属性通常没有差别，但一般文本更偏向数据，而属性更偏向于给予程序以提示（比如重名标签的id）；当然，此外，作为元素还能拥有更详细的子元素，因此更易扩展）

标签名大小写敏感

此外，XML的结构性符号出现在文本中需要使用“实体引用”替代：
| 实体引用 | 对应字符 |
|:---:|:---:|
|`&lt;`|`<`|
|`&gt;`|`>`|
|`&amp;`|`&`|
|`&apos;`|`'`|
|`&quot;`|`"`|
注：在 XML 中，只有字符 "<" 和 "&" 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。

注释方式和HTML相同：
```
<!-- This is a comment --> 
```

### 命名规则
名称可以含字母、数字以及其他的字符 
名称不能以数字或者标点符号开始 
名称不能以字符 “xml”（或者 XML、Xml）开始 
名称不能包含空格

#### 最佳命名习惯
最好使用下划线，而不是“-”、“.”、“:”
在 XML 中，文档中的空格不会被删节。（HTML会合并为一个）


### Namespace
多文档元素重名，可以使用命名空间前缀
```
<h:table xmlns:h="http://www.w3.org/TR/html4/">
   <h:tr>
   <h:td>Apples</h:td>
   <h:td>Bananas</h:td>
   </h:tr>
</h:table>
```
其中，`h:` 就是namespace前缀，带该前缀的开始标签添加了一个 xmlns 属性，为前缀赋予了一个与某个命名空间相关联的限定名称。格式为：
```
xmlns:namespace-prefix="namespaceURI"
```
当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。
注释：用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。不过，很多公司常常会作为指针来使用命名空间指向实际存在的网页，这个网页包含关于命名空间的信息。
如果省略了namespace-prefix，则表示使用默认命名空间

### 文档类型定义
合法的 XML 文档是“形式良好”的 XML 文档，同样遵守文档类型定义 (DTD) 的语法规则：
```
<!DOCTYPE note SYSTEM "Note.dtd">
```
DOCTYPE 声明是对外部 DTD 文件的引用。下面的段落展示了这个文件的内容。
DTD 的作用是定义 XML 文档的结构。它使用一系列合法的元素来定义文档结构：
```
<!DOCTYPE note [
  <!ELEMENT note (to,from,heading,body)>
  <!ELEMENT to      (#PCDATA)>
  <!ELEMENT from    (#PCDATA)>
  <!ELEMENT heading (#PCDATA)>
  <!ELEMENT body    (#PCDATA)>
]> 
```
W3C 的 XML 规范声明：如果 XML 文档存在错误，那么程序就不应当继续处理这个文档。

******

## XPath
XPath是一种表达式语言，用于在 XML 文档中查找信息，它的返回值可能是节点，节点集合，原子值，以及节点和原子值的混合等。
XPath 使用路径表达式来选取 XML 文档中的节点或者节点集。
XPath 包含一个标准函数库

XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。
在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。
在执行XPath时一定要注意上下文。即当前是在哪个节点下执行XPath表达式。这在XMLDOM中很重要。如：在XMLDOM中的selectNodes,selectSingleNode方法的参数都是一个XPath表达式，此时这个XPath表达式的执行上下文就是调用这个方法的节点及它所在的环境。

### 基本语法
/ 分隔节点，假如路径起始于正斜杠( / )，则该斜杠代表文档的根，此路径表示绝对路径
//nn 递归下降，表示自该节点以下的所有名为nn的后代节点
. 当前节点
.. 当前节点的父节点
@aa 名为aa的属性
`*` 统配一个名字（无论是节点名还是属性名，属性名需要前面加@，可以用node() 函数表示任何类型的结点）
nn/text() 结点的文本
nn[] 谓词
+ 使用数字表示第几个nn 结点（可以使用last() 表示最后一个结点，可以使用position()<3 选择前两个结点）
+ 使用tagname表示拥有一个该名字子节点的节点
+ 使用tagname='text'表示拥有一个该名字且文本为指定内容的子节点的节点（也可以用其他的比较运算符）
+ 使用@aa 含有属性aa 的节点
+ 使用@aa='tt'含有属性aa且值为tt
+ 使用not() 对条件取反
可以同时使用多个谓词（多个方括号）
| 路径并集

每一个节点被称为一步，步的语法：
轴名称::节点测试[谓语]

### [轴](http://www.w3school.com.cn/xpath/xpath_axes.asp)
XPath轴(XPath Axes)可定义某个相对于当前节点的节点集：
1. child  选取当前节点的所有子元素，默认
2. parent  选取当前节点的父节点
3. descendant 选取当前节点的所有后代元素（子、孙等），即//
4. ancestor  选取当前节点的所有先辈（父、祖父等）
5. descendant-or-self  选取当前节点的所有后代元素（子、孙等）以及当前节点本身
6. ancestor-or-self  选取当前节点的所有先辈（父、祖父等）以及当前节点本身
7. preceding-sibling 选取当前节点之前的所有同级节点
8. following-sibling 选取当前节点之后的所有同级节点
9. preceding   选取文档中当前节点的开始标签之前的所有节点（不包括祖先结点）
10. following   选取文档中当前节点的结束标签之后的所有节点（不包括祖先结点）
11. self  选取当前节点
12. attribute  选取当前节点的所有属性
13. namespace 选取当前节点的所有命名空间节点

### [运算符](http://www.w3school.com.cn/xpath/xpath_operators.asp)

### [内置函数](http://www.w3school.com.cn/xpath/xpath_functions.asp)
按照参数的不同，可以分为以下类型
#### 节点函数(Node-Set)
#### 数值函数
#### 字符串函数
#### 布尔函数
#### 时间日期函数
#### 序列函数
#### 上下文函数
position()：返回当前正在被处理的节点的 index 位置（第一个元素位置为1）
last()：返回在被处理的节点列表中的项目数目
#### QNames 函数
#### 错误和跟踪函数
